/*
 * Copyright 2016-2019 The Reaktivity Project
 *
 * The Reaktivity Project licenses this file to you under the Apache License,
 * version 2.0 (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at:
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations
 * under the License.
 */
scope protocol
{
    scope codec
    {
        struct AmqpBinary8
        {
            uint8 length;
            octets[length] bytes;
        }

        struct AmqpBinary32
        {
            uint32 length;
            octets[length] bytes;
        }
        
        union AmqpBoolean switch (uint8)
        {
            case 0x56: uint8 booleanType;
            case 0x41: uint8 trueType; // true TODO: default value?
            case 0x42: uint8 falseType; // false
        }

        union AmqpUInt switch (uint8)
        {
            case 0x70: uint32 uIntType;
            case 0x52: uint8 smallUIntType;
            case 0x43: uint8 uIntZeroType; // uint0 TODO: ideal behavior: case 0x43: ;
        }

        union AmqpULong switch (uint8)
        {
            case 0x80: uint64 ulongType;
            case 0x53: uint8 smallULongType;
            case 0x44: uint8 uLongZeroType; // ulong0 TODO: ideal behavior: case 0x44: ;
        }

        union AmqpInt switch (uint8)
        {
            case 0x71: int32 intType;
            case 0x54: int8 smallIntType;
        }

        union AmqpLong switch (uint8)
        {
            case 0x81: int64 longType;
            case 0x55: int8 smallLongType;
        }

        union AmqpBinary switch (uint8)
        {
            case 0xa0: protocol::codec::AmqpBinary8 vbin8;
            case 0xb0: protocol::codec::AmqpBinary32 vbin32;
        }

        union AmqpString switch (uint8)
        {
            case 0xa1: string str8;
            case 0xb1: string32 str32; // TODO: string32 not currently supported
        }

        union AmqpSymbol switch (uint8)
        {
            case 0xa3: string sym8;
            case 0xb3: string32 sym32; // TODO: string32 not currently supported
        }

        union AmqpList switch (uint8)
        {
            case 0x45: int8 listZero; // list0 TODO: ideal behavior: case 0x45: ;
            case 0xc0: // TODO: need to design
            case 0xd0: // TODO: need to design
        }

        union AmqpMap switch (uint8) // TODO:
        {
            case 0xc1: list<protocol::codec::AmqpKeyValue> map8;
            case 0xd1: list<protocol::codec::AmqpKeyValue> map32;
        }

        struct AmqpKeyValue
        {
            protocol::codec::AmqpSymbol key;
            protocol::codec::AmqpSymbol value;
        }

        struct AmqpProperty
        {
            protocol::codec::AmqpSymbol key;
            protocol::codec::AmqpSymbol value; // TODO: not sure about the type
        }

        // 2.8 Definitions
        enum AmqpRole
        {
            SENDER,
            RECEIVER
        }

        enum AmqpSenderSettleMode
        {
            UNSETTLED,
            SETTLED,
            MIZED
        }

        enum AmqpReceiverSettleMode
        {
            FIRST,
            SECOND
        }

        struct Error
        {
            protocol::codec::AmqpError condition;
            protocol::codec::AmqpString description;
            protocol::codec::AmqpMap info;
        }

        enum AmqpError // TODO: values are symbol - need to store values associated with names
        {
             INTERNAL_ERROR,
             NOT_FOUND,
             UNAUTHORIZED_ACCESS,
             DECODE_ERROR,
             RESOURCE_LIMIT_EXCEEDED,
             NOT_ALLOWED,
             INVALID_FIELD,
             NOT_IMPLEMENTED,
             RESOURCE_LOCKED,
             PRECONDITION_FAILED,
             RESOURCE_DELETED,
             ILLEGAL_STATE,
             FRAME_SIZE_TOO_SMALL
        }

        // 3.4 Delivery state
        union AmqpDeliveryState switch (uint8)
        {
            case 0x23: protocol::codec::AmqpReceived received;
            case 0x24: protocol::codec::AmqpList accepted; // TODO: should be empty list
            case 0x25: protocol::codec::AmqpRejected rejected;
            case 0x26: protocol::codec::AmqpList released; // TODO: should be empty list
            case 0x27: protocol::codec::AmqpModified modified;
            case 0x33: protocol::codec::AmqpDeclared declared;
            case 0x34: protocol::codec::AmqpTransactionalState transactionalState;
        }

        union AmqpOutcome switch (uint8)
        {
            case 0x24: protocol::codec::AmqpList accepted; // TODO: should be empty list
            case 0x25: protocol::codec::AmqpRejected rejected;
            case 0x26: protocol::codec::AmqpList released; // TODO: should be empty list
            case 0x27: protocol::codec::AmqpModified modified;
            case 0x33: protocol::codec::AmqpDeclared declared;
        }

        struct AmqpReceived
        {
            protocol::codec::AmqpUInt sectionNumber; // required
            protocol::codec::AmqpULong sectionOffset; // required
        }

        struct AmqpRejected
        {
            protocol::codec::Error error;
        }

        struct AmqpDeclared
        {
            protocol::codec::AmqpBinary txnId; // required
        }

        struct AmqpModified
        {
            protocol::codec::AmqpBoolean deliveryFailed;
            protocol::codec::AmqpBoolean undeliverableHere;
            protocol::codec::AmqpMap messageAnnotations;
        }

        struct AmqpTransactionalState
        {
            protocol::codec::AmqpBinary txnId; // required
            protocol::codec::AmqpOutcome outcome;
        }

        // 3.5 Sources and Targets
        struct AmqpSource
        {
            protocol::codec::AmqpString address;
            protocol::codec::AmqpTerminusDurability durable;
            protocol::codec::AmqpTerminusExpiryPolicy expiryPolicy;
            protocol::codec::AmqpUInt timeout;
            protocol::codec::AmqpBoolean dynamic;
            protocol::codec::AmqpMap dynamicNodeProperties;
            protocol::codec::AmqpStandardDistributionMode distributionMode;
            protocol::codec::AmqpMap filter;
            protocol::codec::AmqpOutcome defaultOutcome;
            list<protocol::codec::AmqpSymbol> outcomes;
            list<protocol::codec::AmqpSymbol> capabilities;
        }

        struct AmqpTarget
        {
            protocol::codec::AmqpString address;
            protocol::codec::AmqpTerminusDurability durable;
            protocol::codec::AmqpTerminusExpiryPolicy expiryPolicy;
            protocol::codec::AmqpUInt timeout;
            protocol::codec::AmqpBoolean dynamic;
            protocol::codec::AmqpMap dynamicNodeProperties;
            list<protocol::codec::AmqpSymbol> capabilities;
        }

        enum AmqpTerminusDurability
        {
            NONE,
            CONFIGURATION,
            UNSETTLED_STATE
        }

        enum AmqpTerminusExpiryPolicy // TODO: values are symbol
        {
            LINK_DETACH,
            SESSION_END,
            CONNECTION_CLOSE,
            NEVER
        }

        enum AmqpStandardDistributionMode // TODO: values are symbol
        {
            MOVE,
            COPY
        }

        // 2.7 Performatives
        struct AmqpOpenFrame // TODO: struct requires all the properties --> need optional fields
        {
            protocol::codec::AmqpString containerId; // required
            protocol::codec::AmqpString hostname;
            protocol::codec::AmqpUInt maxFrameSize;
            uint16 channelMax;
            protocol::codec::AmqpUInt idleTimeOut;
            list<protocol::codec::AmqpSymbol> outgoingLocales;
            list<protocol::codec::AmqpSymbol> incomingLocales;
            list<protocol::codec::AmqpSymbol> offeredCapabilities;
            list<protocol::codec::AmqpSymbol> desiredCapabilities;
            list<protocol::codec::AmqpProperty> properties; // TODO: key is symbol and value can be any
        }

        struct AmqpBeginFrame
        {
            uint16 remoteChannel;
            uint32 nextOutgoingId; // required
            protocol::codec::AmqpUInt incomingWindow; // required
            protocol::codec::AmqpUInt outgoingWindow; // required
            protocol::codec::AmqpUInt handleMax;
            list<protocol::codec::AmqpSymbol> offeredCapabilities;
            list<protocol::codec::AmqpSymbol> desiredCapabilities;
            list<protocol::codec::AmqpProperty> properties;
        }

        struct AmqpAttachFrame
        {
            protocol::codec::AmqpString name; // required
            protocol::codec::AmqpUInt handle; // required
            protocol::codec::AmqpRole role; // required
            protocol::codec::AmqpSenderSettleMode sndSettleMode;
            protocol::codec::AmqpReceiverSettleMode rcvSettleMode;
            protocol::codec::AmqpSource source;
            protocol::codec::AmqpTarget target;
            protocol::codec::AmqpMap unsettled;
            protocol::codec::AmqpBoolean incompleteUnsettled;
            protocol::codec::AmqpUInt initialDeliveryCount;
            protocol::codec::AmqpULong maxMessageSize;
            list<protocol::codec::AmqpSymbol> offeredCapabilities;
            list<protocol::codec::AmqpSymbol> desiredCapabilities;
            list<protocol::codec::AmqpProperty> properties;
        }

        struct AmqpFlowFrame
        {
            protocol::codec::AmqpUInt nextIncomingId;
            protocol::codec::AmqpUInt incomingWindow; // required
            protocol::codec::AmqpUInt nextOutgoingId; // required
            protocol::codec::AmqpUInt outgoingWindow;  // required
            protocol::codec::AmqpUInt handle;
            protocol::codec::AmqpUInt deliveryCount;
            protocol::codec::AmqpUInt linkCredit;
            protocol::codec::AmqpUInt available;
            protocol::codec::AmqpBoolean drain;
            protocol::codec::AmqpBoolean echo;
            list<protocol::codec::AmqpProperty> properties;
        }

        struct AmqpTransferFrame
        {
            protocol::codec::AmqpUInt handle; // required
            protocol::codec::AmqpUInt deliveryId;
            protocol::codec::AmqpBinary deliveryTag;
            protocol::codec::AmqpMessageFormat messageFormat;
            protocol::codec::AmqpBoolean settled;
            protocol::codec::AmqpBoolean more;
            protocol::codec::AmqpReceiverSettleMode rcvSettleMode;
            protocol::codec::AmqpDeliveryState state;
            protocol::codec::AmqpBoolean resume;
            protocol::codec::AmqpBoolean aborted;
            protocol::codec::AmqpBoolean batchable;
        }

        struct AmqpDispositionFrame
        {
            protocol::codec::AmqpRole role; // required
            protocol::codec::AmqpUInt first; // required
            protocol::codec::AmqpUInt last;
            protocol::codec::AmqpBoolean settled;
            protocol::codec::AmqpDeliveryState state;
            protocol::codec::AmqpBoolean batchable;
        }

        struct AmqpDetachFrame
        {
            protocol::codec::AmqpUInt handle; // required
            protocol::codec::AmqpBoolean closed;
            protocol::codec::Error error;
        }

        struct AmqpEndFrame
        {
            protocol::codec::Error error;
        }

        struct AmqpCloseFrame
        {
            protocol::codec::Error error;
        }

        struct AmqpMessageFormat
        {
            octets[3] messageFormat;
            octets[1] version;
        }
    }
}
